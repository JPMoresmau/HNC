 -- Модуль вывода типов
ATTR ASTExpression ExpressionList Definition LetIn
	[
		generalizedTypes : {M.Map String GType}
		finalSubstitution : {MT.MyStack ()}
	|
		counter : Int
	|
	]

ATTR Definition
	[ | | generalizedTypeM : {MT.MyStack GType} ]

ATTR ASTExpression LetIn
	[ | | tauM : {MT.MyStack (MutTerm IntVar MT.T)} ]

ATTR ExpressionList
	[ | | tauM USE {:} {[]} : {[MT.MyStack (MutTerm IntVar MT.T)]} ]

SEM Definition
	| Definition
		-- arguments get fresh type variables
		(where.counter, loc.argAtoms) = MT.freshAtoms @params @lhs.counter
		-- argument types are not generalized, thus S.empty
		where.generalizedTypes = M.union (M.map (\t -> (S.empty, t)) $ M.fromList @loc.argAtoms) @lhs.generalizedTypes

		-- generalizedType используется алгоритмом W _ДО_ того, как создается finalSubstitution
		loc.generalizedTypeM = { if null @params
			then MT.emptyClosureM @where.tauM
			else MT.closureM @lhs.generalizedTypes $ do
 				args <- mapM (MT.convertTv . snd) @loc.argAtoms
				result <- @where.tauM
				return $ (MutTerm . MT.TT) $ args ++ [result]
		}

SEM LetIn
	| Let
		tl.generalizedTypes = M.insert @hd.name (MT.runStack @hd.generalizedTypeM) @lhs.generalizedTypes
		lhs.tauM = fmap snd @hd.generalizedTypeM >> @tl.tauM

SEM ASTExpression
	| Constant
		lhs.tauM = MT.constantType @c
	| Atom
		(lhs.counter, loc.tauM) = xtrace "atom.tau" $ MT.instantiatedType @lhs.counter $ tracedUncondLookup "MilnerTools.lookupAndInstantiate" @name @lhs.generalizedTypes
	| Application
		fn.counter = @lhs.counter + 1
		loc.tauM = MT.unifyM @fn.tauM @arg.tauM $ MT.convertTv $ tv @lhs.counter
